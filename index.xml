<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aleksandr Guljajev</title>
    <link>http://www.itchyknowsdevs.me/</link>
    <description>Recent content on Aleksandr Guljajev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Fri, 26 Feb 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.itchyknowsdevs.me/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hugo on Amazon AWS Lambda integrated with GitHub</title>
      <link>http://www.itchyknowsdevs.me/blog/hugo-on-amazon-aws-lambda-integrated-with-github/</link>
      <pubDate>Fri, 26 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/blog/hugo-on-amazon-aws-lambda-integrated-with-github/</guid>
      <description>

&lt;h1 id=&#34;the-problem:a1ec05e051105cb1bb5549ae149fdde7&#34;&gt;The Problem&lt;/h1&gt;

&lt;p&gt;I love static website generators. I think it&amp;rsquo;s a great iteration over the old approach before dynamic websites became a de-facto standard.&lt;/p&gt;

&lt;p&gt;The most compelling argument towards using static websites is &amp;ldquo;minimum-hosting&amp;rdquo; approach.
The only thing you need is a web server and a domain name.&lt;/p&gt;

&lt;p&gt;You still have the problem of continuos delivery. If you are anything like me, you don&amp;rsquo;t want to keep rebuilding and deploying your website manually.&lt;/p&gt;

&lt;p&gt;Make changes, test locally, push, make a sandwich and reflect on eternity of consciousness in the Universe. The changes are live. Ah, beautiful.&lt;/p&gt;

&lt;h1 id=&#34;inspiration:a1ec05e051105cb1bb5549ae149fdde7&#34;&gt;Inspiration&lt;/h1&gt;

&lt;p&gt;My approach was inspired by &lt;a href=&#34;bezdelev.com/post/hugo-aws-lambda-static-website/&#34;&gt;this blogpost&lt;/a&gt;.
I though, huh, this is cool. Then I set it up and quickly realised its shortcoming: manual S3 website upload.&lt;/p&gt;

&lt;p&gt;I decided to take it a step further and integrate the process with GitHub.&lt;/p&gt;

&lt;h1 id=&#34;prerequisites-process:a1ec05e051105cb1bb5549ae149fdde7&#34;&gt;Prerequisites &amp;amp; process&lt;/h1&gt;

&lt;p&gt;Some familiarity with AWS is required.&lt;/p&gt;

&lt;p&gt;You have configured all the required components on AWS to publish your website:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;S3 bucket with the source files&lt;/li&gt;
&lt;li&gt;Route 53 for DNS&lt;/li&gt;
&lt;li&gt;CloudFront for SSL and load balancing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This guide will only address publishing your static content through Hugo compiler from GitHub to S3 bucket.&lt;/p&gt;

&lt;p&gt;My AWS configuration is very similar described in the post above.&lt;/p&gt;

&lt;p&gt;There are some changes, however:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I don&amp;rsquo;t have the input.&lt;website&gt; bucket, the changes are pulled off GitHub&lt;/li&gt;
&lt;li&gt;I have configured AWS SNS with GitHub WebHooks. Each commit is trigering SNS which in turn is configured as AWS Lambda event source.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;introducing-github-hugo-lambda-integration-project:a1ec05e051105cb1bb5549ae149fdde7&#34;&gt;Introducing GitHub-Hugo-Lambda integration project&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/alex-glv/github-hugo-lambda&#34;&gt;Github Hugo Lambda&lt;/a&gt; project should do most of the configuration for you.
It will initialise Node dependencies, create Lambda code package and upload it on Amazon AWS Lambda.
There don&amp;rsquo;t seem to be a way to create Event source mapping from SNS to Lambda through AWS Cli so you have to do it manually.
You have to create GitHub.com webhook service set-up to fire Amazon SNS event.&lt;/p&gt;

&lt;p&gt;Start by checking out the project:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/alex-glv/github-hugo-lambda&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Create config files from provided samples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp {sample,}.config.mk
cp {sample,}.config.json
cp {sample,}.rolepolicyS3.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the config files, this should be straightforward&lt;/p&gt;

&lt;p&gt;Then, run:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make createsns&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will create an SNS topic.
Now, navigate to GitHub.com project Settings -&amp;gt; Webhooks &amp;amp; services -&amp;gt; Add Service -&amp;gt; Amazon SNS.
Fill in the required values and submit. This should be it for configuring GitHub.
We need to create Roles and Policies to allow Lambda access to our S3 bucket.&lt;/p&gt;

&lt;p&gt;Run &lt;code&gt;make createrole&lt;/code&gt; to create the role and necessary policies.&lt;/p&gt;

&lt;p&gt;Now run:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make initnodedeps &amp;amp;&amp;amp; make build &amp;amp;&amp;amp; make deploy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will pull NodeJS dependencies, zip the files and push it to Amazon Lambda.
After this has been completed, go to Lambda configuration page, add Event source and choose the SNS entry you created earlier.&lt;/p&gt;

&lt;p&gt;At this point, everything should be set.&lt;/p&gt;

&lt;p&gt;NOTE: p7zip is a must for creating the archive. It seems that de-facto zip archiver on Unix does not retain executable flags that are required to run hugo, because it&amp;rsquo;s a compiled executable.&lt;/p&gt;

&lt;p&gt;You can rune the test by clicking &amp;ldquo;Test service&amp;rdquo; from the Github webhooks page and it will send the test payload.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:a1ec05e051105cb1bb5549ae149fdde7&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Hopefully this post and project help you to streamline creation of simple static websites.
Configured once, deployment will be fully automated and you can concentrate on creating value rather than worrying how to publish your website changes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Containers are not real</title>
      <link>http://www.itchyknowsdevs.me/blog/containers-are-not-real/</link>
      <pubDate>Tue, 16 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/blog/containers-are-not-real/</guid>
      <description>

&lt;h1 id=&#34;the-advent-of-containers:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;The advent of containers&lt;/h1&gt;

&lt;p&gt;Containers seem to have turned the industry upside down and marching full ahead to become the dominant way of shipping software.
To uninitiated mortals, Docker seems to be kind of a strange child.
Where does it come from, what&amp;rsquo;s it good at?
It looks like VM, but everyone keeps telling us not to compare it to VMs.
Even though it gained a massive traction, it still has a long way to go to be a de-facto standard every developer should be familiar with.&lt;/p&gt;

&lt;p&gt;In this post I&amp;rsquo;ll go through the elements that make up the software container, what underlying infrastructure allows it to exist and how to make a DIY container on a clean ubuntu machine.&lt;/p&gt;

&lt;p&gt;We will be creating our own busybox container!&lt;/p&gt;

&lt;h1 id=&#34;namespaces:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Namespaces&lt;/h1&gt;

&lt;p&gt;To create illusion of a container, Docker (and alike) utilizes Linux kernel feature - namespaces.&lt;/p&gt;

&lt;p&gt;As the name suggests, namespaces allow isolation of global resources, similar to programming language namespaces that allow the namespace functionality to stay encapsulated from the rest of the codebase.
It appears as if a  process or a group of processes are in control of these resources.&lt;/p&gt;

&lt;p&gt;There are 6 different namespaces that allow isolation of different types of system resources:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UTS&lt;/li&gt;
&lt;li&gt;Mount&lt;/li&gt;
&lt;li&gt;User&lt;/li&gt;
&lt;li&gt;Network&lt;/li&gt;
&lt;li&gt;Proc&lt;/li&gt;
&lt;li&gt;IPC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will not go too deeply in the discusssion of namespaces, you can read more about them in a brilliant series of articles by Michael Kerrisk on linux kernel namespaces. &lt;a href=&#34;https://lwn.net/Articles/531114/&#34;&gt;https://lwn.net/Articles/531114/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So, by utilizing resource isolation processes create an illusion of a standalone container.
Interesting thing that if you search for words &amp;ldquo;containers&amp;rdquo; in linux kernel, you will find nothing related to actual concept of containerization.
This is it, the containers don&amp;rsquo;t actually exist, they are not real, we make them real.
Since the genie is out of the bottle now, let&amp;rsquo;s recreate a busybox container from scratch.&lt;/p&gt;

&lt;h1 id=&#34;prerequisites:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Prerequisites&lt;/h1&gt;

&lt;p&gt;I am using DigitalOcean with a clean Ubuntu 15.10 virtual machine, and nothing more, so you can easily reproduce the results.&lt;/p&gt;

&lt;h1 id=&#34;network-interfaces:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Network interfaces&lt;/h1&gt;

&lt;p&gt;Containers wouldn&amp;rsquo;t be very interesting if they didn&amp;rsquo;t have access to the internet.
It&amp;rsquo;s like lego bricks without the studs (&amp;ldquo;stud&amp;rdquo; seems to be an official term to call those little pimples on Lego bricks &lt;a href=&#34;http://thebrickblogger.com/2010/11/lego-disctionary-basic-term/&#34;&gt;http://thebrickblogger.com/2010/11/lego-disctionary-basic-term/&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Luckily, linux kernel provides an option of network namespaces that allow a process to have its own isolated network stack. We connect that stack with the host network namespace with virtual ethernet devices.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s create our network namespace:
&lt;code&gt;ip netns add container&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ensure that kernel allows packet forwarding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we&amp;rsquo;ll create a pair of virtual ethernet devices. Think of them as a pipe where interfaces are on both ends.
I like to think of them as portals to the alternate universe.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip link add veth0 type veth peer name veth1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We created a pair of interfaces veth0 and veth1.
We&amp;rsquo;ll add a tap device that will bridge our virtual device with the real (or not) hardware adapter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip tuntap add tapm mode tap 
ip link set dev tapm up
ip link add brm type bridge
ip link set dev tapm master brm
ip link set dev veth0 master brm

ip addr add 10.0.0.1/24 dev brm
ip link set dev veth0 up
ip link set dev brm up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And iptables rules to allow traffic forward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we&amp;rsquo;ll move one of them into a separate network namespace which we created before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip link set veth1 netns container 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add the IP address and bring them up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip netns exec container ip addr add dev veth1 10.0.0.2/24
ip netns exec container ip link set dev veth1 up
ip netns exec container ip route add  default via 10.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try out if our container network interface has access to the internet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip netns exec container ping -c1 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If our set-up went well, you should get a successful ping response.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/&#34;&gt;http://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OK, we&amp;rsquo;ve managed the hard part, let&amp;rsquo;s create our container&amp;rsquo;s file system and do the rest of the housekeeping&lt;/p&gt;

&lt;h1 id=&#34;enter-the-namespace:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Enter the namespace&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s enter the configured network namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip netns exec container bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By executing this command, we only separate network namespace. Everything else is still shared with the parent process.
That&amp;rsquo;s right, you can share one or many namespaces with other processes.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s move forward and unshare other namespaces. The only namespace we will not unshare is user namespace, because it makes the whole configuration more complex and is it&amp;rsquo;s not necessary for our demonstrational purposes.&lt;/p&gt;

&lt;p&gt;To unshare namespaces, we&amp;rsquo;ll be using &lt;code&gt;unshare&lt;/code&gt; command.
Unshare command will detach from the namespaces specified by flags &lt;code&gt;-m&lt;/code&gt; (mount namespace), &lt;code&gt;-p&lt;/code&gt; (PID namespace), etcetera.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unshare -m -p -i -f --mount-proc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s also mark mount point as private, so non of our mounts leak:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mount / --make-rprivate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will install busybox chroot environment using the following gist posted by github user &amp;ldquo;weakish&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O https://gist.githubusercontent.com/weakish/927135/raw/40b870c8702c52a8d0ea6d3d689e45228055c7c3/busyroot.sh  &amp;amp;&amp;amp; chmod +x busyroot.sh
./busyroot.sh init
chroot /chroot/ bin/sh
busybox install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above gist creates a chroot environment, bootstraps it with need devices and files, nothing too fancy.&lt;/p&gt;

&lt;p&gt;After executing the commands, we have a fully functioning isolated process with network access and own processes tree.
If you run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see 1, it means that our process has process id 1 on the system.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Hopefully, this post has shed some light on the mystery of containers.
We learned to unshare namespaces, create network configuration that allows access to the internet and create a secure environment isolated from the global state of the host.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Containers are not real</title>
      <link>http://www.itchyknowsdevs.me/post/containers-are-not-real/</link>
      <pubDate>Tue, 16 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/post/containers-are-not-real/</guid>
      <description>

&lt;h1 id=&#34;the-advent-of-containers:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;The advent of containers&lt;/h1&gt;

&lt;p&gt;Containers seem to have turned the industry upside down and marching full ahead to become the dominant way of shipping software.
To uninitiated mortals, Docker seems to be kind of a strange child.
Where does it come from, what&amp;rsquo;s it good at?
It looks like VM, but everyone keeps telling us not to compare it to VMs.
Even though it gained a massive traction, it still has a long way to go to be a de-facto standard every developer should be familiar with.&lt;/p&gt;

&lt;p&gt;In this post I&amp;rsquo;ll go through the elements that make up the software container, what underlying infrastructure allows it to exist and how to make a DIY container on a clean ubuntu machine.&lt;/p&gt;

&lt;p&gt;We will be creating our own busybox container!&lt;/p&gt;

&lt;h1 id=&#34;namespaces:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Namespaces&lt;/h1&gt;

&lt;p&gt;To create illusion of a container, Docker (and alike) utilizes Linux kernel feature - namespaces.&lt;/p&gt;

&lt;p&gt;As the name suggests, namespaces allow isolation of global resources, similar to programming language namespaces that allow the namespace functionality to stay encapsulated from the rest of the codebase.
It appears as if a  process or a group of processes are in control of these resources.&lt;/p&gt;

&lt;p&gt;There are 6 different namespaces that allow isolation of different types of system resources:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UTS&lt;/li&gt;
&lt;li&gt;Mount&lt;/li&gt;
&lt;li&gt;User&lt;/li&gt;
&lt;li&gt;Network&lt;/li&gt;
&lt;li&gt;Proc&lt;/li&gt;
&lt;li&gt;IPC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will not go too deeply in the discusssion of namespaces, you can read more about them in a brilliant series of articles by Michael Kerrisk on linux kernel namespaces. &lt;a href=&#34;https://lwn.net/Articles/531114/&#34;&gt;https://lwn.net/Articles/531114/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So, by utilizing resource isolation processes create an illusion of a standalone container.
Interesting thing that if you search for words &amp;ldquo;containers&amp;rdquo; in linux kernel, you will find nothing related to actual concept of containerization.
This is it, the containers don&amp;rsquo;t actually exist, they are not real, we make them real.
Since the genie is out of the bottle now, let&amp;rsquo;s recreate a busybox container from scratch.&lt;/p&gt;

&lt;h1 id=&#34;prerequisites:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Prerequisites&lt;/h1&gt;

&lt;p&gt;I am using DigitalOcean with a clean Ubuntu 15.10 virtual machine, and nothing more, so you can easily reproduce the results.&lt;/p&gt;

&lt;h1 id=&#34;network-interfaces:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Network interfaces&lt;/h1&gt;

&lt;p&gt;Containers wouldn&amp;rsquo;t be very interesting if they didn&amp;rsquo;t have access to the internet.
It&amp;rsquo;s like lego bricks without the studs (&amp;ldquo;stud&amp;rdquo; seems to be an official term to call those little pimples on Lego bricks &lt;a href=&#34;http://thebrickblogger.com/2010/11/lego-disctionary-basic-term/&#34;&gt;http://thebrickblogger.com/2010/11/lego-disctionary-basic-term/&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Luckily, linux kernel provides an option of network namespaces that allow a process to have its own isolated network stack. We connect that stack with the host network namespace with virtual ethernet devices.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s create our network namespace:
&lt;code&gt;ip netns add container&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ensure that kernel allows packet forwarding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we&amp;rsquo;ll create a pair of virtual ethernet devices. Think of them as a pipe where interfaces are on both ends.
I like to think of them as portals to the alternate universe.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip link add veth0 type veth peer name veth1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We created a pair of interfaces veth0 and veth1.
We&amp;rsquo;ll add a tap device that will bridge our virtual device with the real (or not) hardware adapter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip tuntap add tapm mode tap 
ip link set dev tapm up
ip link add brm type bridge
ip link set dev tapm master brm
ip link set dev veth0 master brm

ip addr add 10.0.0.1/24 dev brm
ip link set dev veth0 up
ip link set dev brm up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And iptables rules to allow traffic forward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we&amp;rsquo;ll move one of them into a separate network namespace which we created before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip link set veth1 netns container 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add the IP address and bring them up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip netns exec container ip addr add dev veth1 10.0.0.2/24
ip netns exec container ip link set dev veth1 up
ip netns exec container ip route add  default via 10.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try out if our container network interface has access to the internet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip netns exec container ping -c1 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If our set-up went well, you should get a successful ping response.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/&#34;&gt;http://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OK, we&amp;rsquo;ve managed the hard part, let&amp;rsquo;s create our container&amp;rsquo;s file system and do the rest of the housekeeping&lt;/p&gt;

&lt;h1 id=&#34;enter-the-namespace:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Enter the namespace&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s enter the configured network namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip netns exec container bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By executing this command, we only separate network namespace. Everything else is still shared with the parent process.
That&amp;rsquo;s right, you can share one or many namespaces with other processes.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s move forward and unshare other namespaces. The only namespace we will not unshare is user namespace, because it makes the whole configuration more complex and is it&amp;rsquo;s not necessary for our demonstrational purposes.&lt;/p&gt;

&lt;p&gt;To unshare namespaces, we&amp;rsquo;ll be using &lt;code&gt;unshare&lt;/code&gt; command.
Unshare command will detach from the namespaces specified by flags &lt;code&gt;-m&lt;/code&gt; (mount namespace), &lt;code&gt;-p&lt;/code&gt; (PID namespace), etcetera.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unshare -m -p -i -f --mount-proc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s also mark mount point as private, so non of our mounts leak:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mount / --make-rprivate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will install busybox chroot environment using the following gist posted by github user &amp;ldquo;weakish&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O https://gist.githubusercontent.com/weakish/927135/raw/40b870c8702c52a8d0ea6d3d689e45228055c7c3/busyroot.sh  &amp;amp;&amp;amp; chmod +x busyroot.sh
./busyroot.sh init
chroot /chroot/ bin/sh
busybox install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above gist creates a chroot environment, bootstraps it with need devices and files, nothing too fancy.&lt;/p&gt;

&lt;p&gt;After executing the commands, we have a fully functioning isolated process with network access and own processes tree.
If you run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see 1, it means that our process has process id 1 on the system.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:c8e2a09ea174ff8e7c9537b614f3c385&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Hopefully, this post has shed some light on the mystery of containers.
We learned to unshare namespaces, create network configuration that allows access to the internet and create a secure environment isolated from the global state of the host.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://www.itchyknowsdevs.me/about/</link>
      <pubDate>Sat, 22 Aug 2015 06:42:21 -0700</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/about/</guid>
      <description>&lt;p&gt;This website is called ItchyKnowsDevs.
It&amp;rsquo;s a play on words Itchy Nose Developers. Which doesn&amp;rsquo;t make much sense either.&lt;/p&gt;

&lt;p&gt;My name is Aleksandr Guljajev.&lt;/p&gt;

&lt;p&gt;I reside in Amsterdam, the Netherlands.
I am a freelance software developer.&lt;/p&gt;

&lt;p&gt;I love progress.
I love learning.
I love customizing and tailoring the tools I use.
I love technology and innovation.
I love tinkering, hacking and exploring.
I hate most technologies, programming languages and operating systems.
I hate flame wars on what&amp;rsquo;s better. It&amp;rsquo;s what works for you or what doesn&amp;rsquo;t.
I hate premature optimisation.
I hate arguments for the sake of drama.
I prefer learning concepts over implementation. That&amp;rsquo;s why I try to learn the underlying principles instead of memorizing CLI commands.&lt;/p&gt;

&lt;p&gt;In this blog I write mostly about the things I love. But occasionally about the things I hate.&lt;/p&gt;

&lt;p&gt;I love this quote by Mark Twain: &amp;ldquo;Whenever you find yourself on the side of the majority, it is time to pause and reflect.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;That said, I love reflecting.&lt;/p&gt;

&lt;p&gt;My email address is gulyayev.alex at gmail.com. Write me about the things you hate and love, or the projects you are working on.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>colophon</title>
      <link>http://www.itchyknowsdevs.me/colophon/</link>
      <pubDate>Sat, 22 Aug 2015 06:28:26 -0700</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/colophon/</guid>
      <description>&lt;p&gt;This website is a personal homepage.&lt;/p&gt;

&lt;p&gt;The site is built with &lt;a target=&#34;_blank&#34; href=&#34;//gohugo.io&#34;&gt;Hugo&lt;/a&gt;—a static site generator made with Go. The website &lt;a href=&#34;http://www.itchyknowsdevs.me/&#34;&gt;source code&lt;/a&gt; is available on GitHub. It uses the &lt;a target=&#34;_blank&#34; href=&#34;//github.com/nishanths/cocoa-hugo-theme&#34;&gt;cocoa&lt;/a&gt; theme. The posts are written in Markdown.&lt;/p&gt;

&lt;p&gt;The primary font face is Open Sans and the monospace font face is Ubuntu Mono. The social icons are from the Ionicons font set. CSS classes for code syntax highlighting are inserted during compile-time by Hugo using Pygments.&lt;/p&gt;

&lt;p&gt;If you find errors, &lt;a href=&#34;http://www.itchyknowsdevs.me/&#34;&gt;please let me know&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Code</title>
      <link>http://www.itchyknowsdevs.me/code/</link>
      <pubDate>Wed, 19 Aug 2015 20:29:37 -0700</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/code/</guid>
      <description>&lt;p&gt;I enjoy writing Go, Clojure, PHP, Java, NodeJS, &amp;ldquo;Hobby&amp;rdquo; C.
I contribute to open source software projects.&lt;/p&gt;

&lt;p&gt;Go to my &lt;a href=&#34;http://github.com/alex-glv&#34;&gt;github.com profile&lt;/a&gt; to see what projects I contribute to.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.itchyknowsdevs.me/about-this-site/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/about-this-site/</guid>
      <description>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&#34;canonical&#34; href=&#34;http://www.itchyknowsdevs.me/colophon&#34;/&gt;
    &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;/&gt;
    &lt;meta http-equiv=&#34;refresh&#34; content=&#34;0;url=/colophon&#34;/&gt;
  &lt;/head&gt;
&lt;/html&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.itchyknowsdevs.me/posts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/posts/</guid>
      <description>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&#34;canonical&#34; href=&#34;http://www.itchyknowsdevs.me/blog&#34;/&gt;
    &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;/&gt;
    &lt;meta http-equiv=&#34;refresh&#34; content=&#34;0;url=/blog&#34;/&gt;
  &lt;/head&gt;
&lt;/html&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.itchyknowsdevs.me/writing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.itchyknowsdevs.me/writing/</guid>
      <description>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&#34;canonical&#34; href=&#34;http://www.itchyknowsdevs.me/posts&#34;/&gt;
    &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;/&gt;
    &lt;meta http-equiv=&#34;refresh&#34; content=&#34;0;url=/posts&#34;/&gt;
  &lt;/head&gt;
&lt;/html&gt;
</description>
    </item>
    
  </channel>
</rss>